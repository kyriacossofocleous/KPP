/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                                                                  */
/* Linear Algebra Data and Routines File                            */
/*                                                                  */
/* Generated by KPP-2.2.3 symbolic chemistry Kinetics PreProcessor  */
/*       (http://www.cs.vt.edu/~asandu/Software/KPP)                */
/* KPP is distributed under GPL, the general public licence         */
/*       (http://www.gnu.org/copyleft/gpl.html)                     */
/* (C) 1995-1997, V. Damian & A. Sandu, CGRER, Univ. Iowa           */
/* (C) 1997-2005, A. Sandu, Michigan Tech, Virginia Tech            */
/*     With important contributions from:                           */
/*        M. Damian, Villanova University, USA                      */
/*        R. Sander, Max-Planck Institute for Chemistry, Mainz, Germany */
/*                                                                  */
/* File                 : cbm4_enh_LinearAlgebra.c                  */
/* Time                 : Fri Mar 18 18:58:28 2022                  */
/* Working directory    : /home/kyriacos/CyprusInstitute/kpp/cbm4_enh */
/* Equation file        : cbm4_enh.kpp                              */
/* Output root filename : cbm4_enh                                  */
/*                                                                  */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <sys/time.h>
#include <xmmintrin.h>
#include <float.h>
#include "cbm4_enh_Parameters.h"
#include "cbm4_enh_Global.h"
#include "cbm4_enh_Sparse.h"


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                                                                  */
/* SPARSE_UTIL - SPARSE utility functions                           */
/*   Arguments :                                                    */
/*                                                                  */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


int KppDecomp( float *JVS )
{
float W[32];
float a;
int k, kk, j, jj;

  for( k = 0; k < 32; k++ ) {
    if( JVS[ LU_DIAG[k] ] == 0.0 ) return k+1;
    for( kk = LU_CROW[k]; kk < LU_CROW[k+1]; kk++ )
      W[ LU_ICOL[kk] ] = JVS[kk];
    for( kk = LU_CROW[k]; kk < LU_DIAG[k]; kk++ ) {
      j = LU_ICOL[kk];
      a = -W[j] / JVS[ LU_DIAG[j] ];
      W[j] = -a;
      for( jj = LU_DIAG[j]+1; jj < LU_CROW[j+1]; jj++ )
        W[ LU_ICOL[jj] ] += a*JVS[jj];
    }
    for( kk = LU_CROW[k]; kk < LU_CROW[k+1]; kk++ )
      JVS[kk] = W[ LU_ICOL[kk] ];
  }
  return 0;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Sparse LU factorization, complex
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
int KppDecompCmplxR( float JVSR[], float JVSI[] )
{
   float WR[NVAR], WI[NVAR];
   float ar, ai, den;
   int k, kk, j, jj;

   for( k = 0; k < NVAR; k++ ) {
	if( JVSR[ LU_DIAG[k] ] == 0.0 ) return k+1;
	if( JVSI[ LU_DIAG[k] ] == 0.0 ) return k+1;
	for( kk = LU_CROW[k]; kk < LU_CROW[k+1]; kk++ ) {
		WR[ LU_ICOL[kk] ] = JVSR[kk];
		WI[ LU_ICOL[kk] ] = JVSI[kk];
	}
	for( kk = LU_CROW[k]; kk < LU_DIAG[k]; kk++ ) {
	   j = LU_ICOL[kk];
	   den = JVSR[LU_DIAG[j]]*JVSR[LU_DIAG[j]] + JVSI[LU_DIAG[j]]*JVSI[LU_DIAG[j]];
	   ar = -(WR[j]*JVSR[LU_DIAG[j]] + WI[j]*JVSI[LU_DIAG[j]])/den;
	   ai = -(WI[j]*JVSR[LU_DIAG[j]] - WR[j]*JVSI[LU_DIAG[j]])/den;
	   WR[j] = -ar;
	   WI[j] = -ai;
	   for( jj = LU_DIAG[j]+1; jj < LU_CROW[j+1]; jj++ ) {
		   WR[ LU_ICOL[jj] ] = WR[ LU_ICOL[jj] ] + ar*JVSR[jj] - ai*JVSI[jj];
		   WI[ LU_ICOL[jj] ] = WI[ LU_ICOL[jj] ] + ar*JVSI[jj] + ai*JVSR[jj];
	   }
	}
	for( kk = LU_CROW[k]; kk < LU_CROW[k+1]; kk++ ) {
	   JVSR[kk] = WR[ LU_ICOL[kk] ];
	   JVSI[kk] = WI[ LU_ICOL[kk] ];
	}
   }
   return 0;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Complex sparse solve subroutine using indirect addressing
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void KppSolveCmplxR(float JVSR[], float JVSI[], float XR[], float XI[])
{
   int i, j;
   float sumr, sumi, den;

   for ( i = 0; i < NVAR; i++ ) {
	for ( j = LU_CROW[i]; j < LU_DIAG[i]; j++ ) {
	   XR[i] = XR[i] - (JVSR[j]*XR[LU_ICOL[j]] - JVSI[j]*XI[LU_ICOL[j]]);
	   XI[i] = XI[i] - (JVSR[j]*XI[LU_ICOL[j]] + JVSI[j]*XR[LU_ICOL[j]]);
	}
   }
   
   for ( i = NVAR-1; i >= 0; i-- ) {
	sumr = XR[i];
	sumi = XI[i];
	for ( j = LU_DIAG[i]+1; j < LU_CROW[i+1]; j++) {
	   sumr = sumr - (JVSR[j]*XR[LU_ICOL[j]] - JVSI[j]*XI[LU_ICOL[j]]);
	   sumi = sumi - (JVSR[j]*XI[LU_ICOL[j]] + JVSI[j]*XR[LU_ICOL[j]]);
	}
	den = JVSR[LU_DIAG[i]]*JVSR[LU_DIAG[i]] + JVSI[LU_DIAG[i]]*JVSI[LU_DIAG[i]];
  	XR[i] = (sumr*JVSR[LU_DIAG[i]] + sumi*JVSI[LU_DIAG[i]])/den; 
  	XI[i] = (sumi*JVSR[LU_DIAG[i]] - sumr*JVSI[LU_DIAG[i]])/den;
   }
}
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	END FUNCTION KppSolveCmplxR
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* End of SPARSE_UTIL function                                      */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                                                                  */
/* KppSolve - sparse back substitution                              */
/*   Arguments :                                                    */
/*      JVS       - sparse Jacobian of variables                    */
/*      X         - Vector for variables                            */
/*                                                                  */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

void KppSolve( 
  float JVS[],                           /* sparse Jacobian of variables */
  float X[]                              /* Vector for variables */
)
{
  X[10] = X[10]-JVS[37]*X[4]-JVS[38]*X[6];
  X[11] = X[11]-JVS[42]*X[5];
  X[13] = X[13]-JVS[54]*X[4]-JVS[55]*X[6]-JVS[56]*X[10];
  X[14] = X[14]-JVS[61]*X[6];
  X[15] = X[15]-JVS[67]*X[14];
  X[17] = X[17]-JVS[84]*X[4]-JVS[85]*X[6]-JVS[86]*X[12]-JVS[87]*X[13]
         -JVS[88]*X[14]-JVS[89]*X[16];
  X[18] = X[18]-JVS[104]*X[10]-JVS[105]*X[13];
  X[19] = X[19]-JVS[111]*X[6]-JVS[112]*X[12];
  X[20] = X[20]-JVS[121]*X[16]-JVS[122]*X[18];
  X[22] = X[22]-JVS[139]*X[21];
  X[23] = X[23]-JVS[145]*X[12]-JVS[146]*X[16]-JVS[147]*X[18]-JVS[148]
         *X[19]-JVS[149]*X[21]-JVS[150]*X[22];
  X[24] = X[24]-JVS[158]*X[16]-JVS[159]*X[18]-JVS[160]*X[21]-JVS[161]
         *X[22];
  X[25] = X[25]-JVS[169]*X[2]-JVS[170]*X[3]-JVS[171]*X[5]-JVS[172]*X[8]
         -JVS[173]*X[9]-JVS[174]*X[10]-JVS[175]*X[12]-JVS[176]*X[13]
         -JVS[177]*X[17]-JVS[178]*X[18]-JVS[179]*X[19]-JVS[180]*X[21]
         -JVS[181]*X[22]-JVS[182]*X[23]-JVS[183]*X[24];
  X[26] = X[26]-JVS[191]*X[0]-JVS[192]*X[1]-JVS[193]*X[4]-JVS[194]*X[6]
         -JVS[195]*X[8]-JVS[196]*X[9]-JVS[197]*X[11]-JVS[198]*X[13]
         -JVS[199]*X[14]-JVS[200]*X[15]-JVS[201]*X[16]-JVS[202]*X[18]
         -JVS[203]*X[19]-JVS[204]*X[20]-JVS[205]*X[21]-JVS[206]*X[22]
         -JVS[207]*X[23]-JVS[208]*X[24]-JVS[209]*X[25];
  X[27] = X[27]-JVS[216]*X[1]-JVS[217]*X[4]-JVS[218]*X[6]-JVS[219]*X[9]
         -JVS[220]*X[10]-JVS[221]*X[12]-JVS[222]*X[13]-JVS[223]*X[14]
         -JVS[224]*X[15]-JVS[225]*X[16]-JVS[226]*X[18]-JVS[227]*X[19]
         -JVS[228]*X[20]-JVS[229]*X[21]-JVS[230]*X[22]-JVS[231]*X[23]
         -JVS[232]*X[24]-JVS[233]*X[25]-JVS[234]*X[26];
  X[28] = X[28]-JVS[240]*X[0]-JVS[241]*X[16]-JVS[242]*X[20]-JVS[243]
         *X[21]-JVS[244]*X[22]-JVS[245]*X[23]-JVS[246]*X[24]-JVS[247]
         *X[25]-JVS[248]*X[26]-JVS[249]*X[27];
  X[29] = X[29]-JVS[254]*X[5]-JVS[255]*X[11]-JVS[256]*X[13]-JVS[257]
         *X[20]-JVS[258]*X[21]-JVS[259]*X[22]-JVS[260]*X[23]-JVS[261]
         *X[24]-JVS[262]*X[25]-JVS[263]*X[26]-JVS[264]*X[27]-JVS[265]
         *X[28];
  X[30] = X[30]-JVS[269]*X[7]-JVS[270]*X[8]-JVS[271]*X[10]-JVS[272]
         *X[12]-JVS[273]*X[17]-JVS[274]*X[18]-JVS[275]*X[19]-JVS[276]
         *X[21]-JVS[277]*X[22]-JVS[278]*X[23]-JVS[279]*X[24]-JVS[280]
         *X[25]-JVS[281]*X[26]-JVS[282]*X[27]-JVS[283]*X[28]-JVS[284]
         *X[29];
  X[31] = X[31]-JVS[287]*X[2]-JVS[288]*X[14]-JVS[289]*X[18]-JVS[290]
         *X[21]-JVS[291]*X[23]-JVS[292]*X[24]-JVS[293]*X[25]-JVS[294]
         *X[26]-JVS[295]*X[27]-JVS[296]*X[28]-JVS[297]*X[29]-JVS[298]
         *X[30];
  X[31] = X[31]/JVS[299];
  X[30] = (X[30]-JVS[286]*X[31])/(JVS[285]);
  X[29] = (X[29]-JVS[267]*X[30]-JVS[268]*X[31])/(JVS[266]);
  X[28] = (X[28]-JVS[251]*X[29]-JVS[252]*X[30]-JVS[253]*X[31])
         /(JVS[250]);
  X[27] = (X[27]-JVS[236]*X[28]-JVS[237]*X[29]-JVS[238]*X[30]-JVS[239]
         *X[31])/(JVS[235]);
  X[26] = (X[26]-JVS[211]*X[27]-JVS[212]*X[28]-JVS[213]*X[29]-JVS[214]
         *X[30]-JVS[215]*X[31])/(JVS[210]);
  X[25] = (X[25]-JVS[185]*X[26]-JVS[186]*X[27]-JVS[187]*X[28]-JVS[188]
         *X[29]-JVS[189]*X[30]-JVS[190]*X[31])/(JVS[184]);
  X[24] = (X[24]-JVS[163]*X[25]-JVS[164]*X[26]-JVS[165]*X[27]-JVS[166]
         *X[28]-JVS[167]*X[29]-JVS[168]*X[30])/(JVS[162]);
  X[23] = (X[23]-JVS[152]*X[24]-JVS[153]*X[25]-JVS[154]*X[26]-JVS[155]
         *X[28]-JVS[156]*X[29]-JVS[157]*X[30])/(JVS[151]);
  X[22] = (X[22]-JVS[141]*X[24]-JVS[142]*X[26]-JVS[143]*X[28]-JVS[144]
         *X[29])/(JVS[140]);
  X[21] = (X[21]-JVS[135]*X[24]-JVS[136]*X[26]-JVS[137]*X[28]-JVS[138]
         *X[29])/(JVS[134]);
  X[20] = (X[20]-JVS[124]*X[21]-JVS[125]*X[22]-JVS[126]*X[23]-JVS[127]
         *X[24]-JVS[128]*X[26]-JVS[129]*X[27]-JVS[130]*X[28]-JVS[131]
         *X[29]-JVS[132]*X[30]-JVS[133]*X[31])/(JVS[123]);
  X[19] = (X[19]-JVS[114]*X[21]-JVS[115]*X[22]-JVS[116]*X[24]-JVS[117]
         *X[25]-JVS[118]*X[26]-JVS[119]*X[28]-JVS[120]*X[29])
         /(JVS[113]);
  X[18] = (X[18]-JVS[107]*X[24]-JVS[108]*X[26]-JVS[109]*X[29]-JVS[110]
         *X[30])/(JVS[106]);
  X[17] = (X[17]-JVS[91]*X[18]-JVS[92]*X[19]-JVS[93]*X[21]-JVS[94]
         *X[22]-JVS[95]*X[23]-JVS[96]*X[24]-JVS[97]*X[25]-JVS[98]*X[26]
         -JVS[99]*X[27]-JVS[100]*X[28]-JVS[101]*X[29]-JVS[102]*X[30]
         -JVS[103]*X[31])/(JVS[90]);
  X[16] = (X[16]-JVS[80]*X[21]-JVS[81]*X[24]-JVS[82]*X[26]-JVS[83]
         *X[28])/(JVS[79]);
  X[15] = (X[15]-JVS[69]*X[16]-JVS[70]*X[18]-JVS[71]*X[20]-JVS[72]
         *X[21]-JVS[73]*X[22]-JVS[74]*X[23]-JVS[75]*X[24]-JVS[76]*X[26]
         -JVS[77]*X[28]-JVS[78]*X[29])/(JVS[68]);
  X[14] = (X[14]-JVS[63]*X[18]-JVS[64]*X[21]-JVS[65]*X[24]-JVS[66]
         *X[26])/(JVS[62]);
  X[13] = (X[13]-JVS[58]*X[26]-JVS[59]*X[29]-JVS[60]*X[30])/(JVS[57]);
  X[12] = (X[12]-JVS[51]*X[19]-JVS[52]*X[25]-JVS[53]*X[26])/(JVS[50]);
  X[11] = (X[11]-JVS[44]*X[13]-JVS[45]*X[20]-JVS[46]*X[23]-JVS[47]
         *X[25]-JVS[48]*X[26]-JVS[49]*X[29])/(JVS[43]);
  X[10] = (X[10]-JVS[40]*X[26]-JVS[41]*X[30])/(JVS[39]);
  X[9] = (X[9]-JVS[34]*X[25]-JVS[35]*X[26]-JVS[36]*X[27])/(JVS[33]);
  X[8] = (X[8]-JVS[30]*X[25]-JVS[31]*X[26]-JVS[32]*X[30])/(JVS[29]);
  X[7] = (X[7]-JVS[21]*X[12]-JVS[22]*X[19]-JVS[23]*X[21]-JVS[24]*X[22]
        -JVS[25]*X[26]-JVS[26]*X[28]-JVS[27]*X[29]-JVS[28]*X[30])
        /(JVS[20]);
  X[6] = (X[6]-JVS[19]*X[26])/(JVS[18]);
  X[5] = (X[5]-JVS[16]*X[25]-JVS[17]*X[29])/(JVS[15]);
  X[4] = (X[4]-JVS[14]*X[26])/(JVS[13]);
  X[3] = (X[3]-JVS[9]*X[13]-JVS[10]*X[25]-JVS[11]*X[26]-JVS[12]*X[29])
        /(JVS[8]);
  X[2] = (X[2]-JVS[6]*X[25]-JVS[7]*X[31])/(JVS[5]);
  X[1] = (X[1]-JVS[3]*X[26]-JVS[4]*X[27])/(JVS[2]);
  X[0] = (X[0]-JVS[1]*X[24])/(JVS[0]);
}

/* End of KppSolve function                                         */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                                                                  */
/* KppSolveTR - sparse, transposed back substitution                */
/*   Arguments :                                                    */
/*      JVS       - sparse Jacobian of variables                    */
/*      X         - Vector for variables                            */
/*      XX        - Vector for output variables                     */
/*                                                                  */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

void KppSolveTR( 
  float JVS[],                           /* sparse Jacobian of variables */
  float X[],                             /* Vector for variables */
  float XX[]                             /* Vector for output variables */
)
{
  XX[0] = X[0]/JVS[0];
  XX[1] = X[1]/JVS[2];
  XX[2] = X[2]/JVS[5];
  XX[3] = X[3]/JVS[8];
  XX[4] = X[4]/JVS[13];
  XX[5] = X[5]/JVS[15];
  XX[6] = X[6]/JVS[18];
  XX[7] = X[7]/JVS[20];
  XX[8] = X[8]/JVS[29];
  XX[9] = X[9]/JVS[33];
  XX[10] = X[10]/JVS[39];
  XX[11] = X[11]/JVS[43];
  XX[12] = (X[12]-JVS[21]*XX[7])/(JVS[50]);
  XX[13] = (X[13]-JVS[9]*XX[3]-JVS[44]*XX[11])/(JVS[57]);
  XX[14] = X[14]/JVS[62];
  XX[15] = X[15]/JVS[68];
  XX[16] = (X[16]-JVS[69]*XX[15])/(JVS[79]);
  XX[17] = X[17]/JVS[90];
  XX[18] = (X[18]-JVS[63]*XX[14]-JVS[70]*XX[15]-JVS[91]*XX[17])
          /(JVS[106]);
  XX[19] = (X[19]-JVS[22]*XX[7]-JVS[51]*XX[12]-JVS[92]*XX[17])
          /(JVS[113]);
  XX[20] = (X[20]-JVS[45]*XX[11]-JVS[71]*XX[15])/(JVS[123]);
  XX[21] = (X[21]-JVS[23]*XX[7]-JVS[64]*XX[14]-JVS[72]*XX[15]-JVS[80]
          *XX[16]-JVS[93]*XX[17]-JVS[114]*XX[19]-JVS[124]*XX[20])
          /(JVS[134]);
  XX[22] = (X[22]-JVS[24]*XX[7]-JVS[73]*XX[15]-JVS[94]*XX[17]-JVS[115]
          *XX[19]-JVS[125]*XX[20])/(JVS[140]);
  XX[23] = (X[23]-JVS[46]*XX[11]-JVS[74]*XX[15]-JVS[95]*XX[17]-JVS[126]
          *XX[20])/(JVS[151]);
  XX[24] = (X[24]-JVS[1]*XX[0]-JVS[65]*XX[14]-JVS[75]*XX[15]-JVS[81]
          *XX[16]-JVS[96]*XX[17]-JVS[107]*XX[18]-JVS[116]*XX[19]
          -JVS[127]*XX[20]-JVS[135]*XX[21]-JVS[141]*XX[22]-JVS[152]
          *XX[23])/(JVS[162]);
  XX[25] = (X[25]-JVS[6]*XX[2]-JVS[10]*XX[3]-JVS[16]*XX[5]-JVS[30]
          *XX[8]-JVS[34]*XX[9]-JVS[47]*XX[11]-JVS[52]*XX[12]-JVS[97]
          *XX[17]-JVS[117]*XX[19]-JVS[153]*XX[23]-JVS[163]*XX[24])
          /(JVS[184]);
  XX[26] = (X[26]-JVS[3]*XX[1]-JVS[11]*XX[3]-JVS[14]*XX[4]-JVS[19]
          *XX[6]-JVS[25]*XX[7]-JVS[31]*XX[8]-JVS[35]*XX[9]-JVS[40]
          *XX[10]-JVS[48]*XX[11]-JVS[53]*XX[12]-JVS[58]*XX[13]-JVS[66]
          *XX[14]-JVS[76]*XX[15]-JVS[82]*XX[16]-JVS[98]*XX[17]-JVS[108]
          *XX[18]-JVS[118]*XX[19]-JVS[128]*XX[20]-JVS[136]*XX[21]
          -JVS[142]*XX[22]-JVS[154]*XX[23]-JVS[164]*XX[24]-JVS[185]
          *XX[25])/(JVS[210]);
  XX[27] = (X[27]-JVS[4]*XX[1]-JVS[36]*XX[9]-JVS[99]*XX[17]-JVS[129]
          *XX[20]-JVS[165]*XX[24]-JVS[186]*XX[25]-JVS[211]*XX[26])
          /(JVS[235]);
  XX[28] = (X[28]-JVS[26]*XX[7]-JVS[77]*XX[15]-JVS[83]*XX[16]-JVS[100]
          *XX[17]-JVS[119]*XX[19]-JVS[130]*XX[20]-JVS[137]*XX[21]
          -JVS[143]*XX[22]-JVS[155]*XX[23]-JVS[166]*XX[24]-JVS[187]
          *XX[25]-JVS[212]*XX[26]-JVS[236]*XX[27])/(JVS[250]);
  XX[29] = (X[29]-JVS[12]*XX[3]-JVS[17]*XX[5]-JVS[27]*XX[7]-JVS[49]
          *XX[11]-JVS[59]*XX[13]-JVS[78]*XX[15]-JVS[101]*XX[17]
          -JVS[109]*XX[18]-JVS[120]*XX[19]-JVS[131]*XX[20]-JVS[138]
          *XX[21]-JVS[144]*XX[22]-JVS[156]*XX[23]-JVS[167]*XX[24]
          -JVS[188]*XX[25]-JVS[213]*XX[26]-JVS[237]*XX[27]-JVS[251]
          *XX[28])/(JVS[266]);
  XX[30] = (X[30]-JVS[28]*XX[7]-JVS[32]*XX[8]-JVS[41]*XX[10]-JVS[60]
          *XX[13]-JVS[102]*XX[17]-JVS[110]*XX[18]-JVS[132]*XX[20]
          -JVS[157]*XX[23]-JVS[168]*XX[24]-JVS[189]*XX[25]-JVS[214]
          *XX[26]-JVS[238]*XX[27]-JVS[252]*XX[28]-JVS[267]*XX[29])
          /(JVS[285]);
  XX[31] = (X[31]-JVS[7]*XX[2]-JVS[103]*XX[17]-JVS[133]*XX[20]-JVS[190]
          *XX[25]-JVS[215]*XX[26]-JVS[239]*XX[27]-JVS[253]*XX[28]
          -JVS[268]*XX[29]-JVS[286]*XX[30])/(JVS[299]);
  XX[31] = XX[31];
  XX[30] = XX[30]-JVS[298]*XX[31];
  XX[29] = XX[29]-JVS[284]*XX[30]-JVS[297]*XX[31];
  XX[28] = XX[28]-JVS[265]*XX[29]-JVS[283]*XX[30]-JVS[296]*XX[31];
  XX[27] = XX[27]-JVS[249]*XX[28]-JVS[264]*XX[29]-JVS[282]*XX[30]
          -JVS[295]*XX[31];
  XX[26] = XX[26]-JVS[234]*XX[27]-JVS[248]*XX[28]-JVS[263]*XX[29]
          -JVS[281]*XX[30]-JVS[294]*XX[31];
  XX[25] = XX[25]-JVS[209]*XX[26]-JVS[233]*XX[27]-JVS[247]*XX[28]
          -JVS[262]*XX[29]-JVS[280]*XX[30]-JVS[293]*XX[31];
  XX[24] = XX[24]-JVS[183]*XX[25]-JVS[208]*XX[26]-JVS[232]*XX[27]
          -JVS[246]*XX[28]-JVS[261]*XX[29]-JVS[279]*XX[30]-JVS[292]
          *XX[31];
  XX[23] = XX[23]-JVS[182]*XX[25]-JVS[207]*XX[26]-JVS[231]*XX[27]
          -JVS[245]*XX[28]-JVS[260]*XX[29]-JVS[278]*XX[30]-JVS[291]
          *XX[31];
  XX[22] = XX[22]-JVS[150]*XX[23]-JVS[161]*XX[24]-JVS[181]*XX[25]
          -JVS[206]*XX[26]-JVS[230]*XX[27]-JVS[244]*XX[28]-JVS[259]
          *XX[29]-JVS[277]*XX[30];
  XX[21] = XX[21]-JVS[139]*XX[22]-JVS[149]*XX[23]-JVS[160]*XX[24]
          -JVS[180]*XX[25]-JVS[205]*XX[26]-JVS[229]*XX[27]-JVS[243]
          *XX[28]-JVS[258]*XX[29]-JVS[276]*XX[30]-JVS[290]*XX[31];
  XX[20] = XX[20]-JVS[204]*XX[26]-JVS[228]*XX[27]-JVS[242]*XX[28]
          -JVS[257]*XX[29];
  XX[19] = XX[19]-JVS[148]*XX[23]-JVS[179]*XX[25]-JVS[203]*XX[26]
          -JVS[227]*XX[27]-JVS[275]*XX[30];
  XX[18] = XX[18]-JVS[122]*XX[20]-JVS[147]*XX[23]-JVS[159]*XX[24]
          -JVS[178]*XX[25]-JVS[202]*XX[26]-JVS[226]*XX[27]-JVS[274]
          *XX[30]-JVS[289]*XX[31];
  XX[17] = XX[17]-JVS[177]*XX[25]-JVS[273]*XX[30];
  XX[16] = XX[16]-JVS[89]*XX[17]-JVS[121]*XX[20]-JVS[146]*XX[23]
          -JVS[158]*XX[24]-JVS[201]*XX[26]-JVS[225]*XX[27]-JVS[241]
          *XX[28];
  XX[15] = XX[15]-JVS[200]*XX[26]-JVS[224]*XX[27];
  XX[14] = XX[14]-JVS[67]*XX[15]-JVS[88]*XX[17]-JVS[199]*XX[26]
          -JVS[223]*XX[27]-JVS[288]*XX[31];
  XX[13] = XX[13]-JVS[87]*XX[17]-JVS[105]*XX[18]-JVS[176]*XX[25]
          -JVS[198]*XX[26]-JVS[222]*XX[27]-JVS[256]*XX[29];
  XX[12] = XX[12]-JVS[86]*XX[17]-JVS[112]*XX[19]-JVS[145]*XX[23]
          -JVS[175]*XX[25]-JVS[221]*XX[27]-JVS[272]*XX[30];
  XX[11] = XX[11]-JVS[197]*XX[26]-JVS[255]*XX[29];
  XX[10] = XX[10]-JVS[56]*XX[13]-JVS[104]*XX[18]-JVS[174]*XX[25]
          -JVS[220]*XX[27]-JVS[271]*XX[30];
  XX[9] = XX[9]-JVS[173]*XX[25]-JVS[196]*XX[26]-JVS[219]*XX[27];
  XX[8] = XX[8]-JVS[172]*XX[25]-JVS[195]*XX[26]-JVS[270]*XX[30];
  XX[7] = XX[7]-JVS[269]*XX[30];
  XX[6] = XX[6]-JVS[38]*XX[10]-JVS[55]*XX[13]-JVS[61]*XX[14]-JVS[85]
         *XX[17]-JVS[111]*XX[19]-JVS[194]*XX[26]-JVS[218]*XX[27];
  XX[5] = XX[5]-JVS[42]*XX[11]-JVS[171]*XX[25]-JVS[254]*XX[29];
  XX[4] = XX[4]-JVS[37]*XX[10]-JVS[54]*XX[13]-JVS[84]*XX[17]-JVS[193]
         *XX[26]-JVS[217]*XX[27];
  XX[3] = XX[3]-JVS[170]*XX[25];
  XX[2] = XX[2]-JVS[169]*XX[25]-JVS[287]*XX[31];
  XX[1] = XX[1]-JVS[192]*XX[26]-JVS[216]*XX[27];
  XX[0] = XX[0]-JVS[191]*XX[26]-JVS[240]*XX[28];
}

/* End of KppSolveTR function                                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                                                                  */
/* BLAS_UTIL - BLAS-LIKE utility functions                          */
/*   Arguments :                                                    */
/*                                                                  */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  
/*--------------------------------------------------------------
 
  BLAS/LAPACK-like subroutines used by the integration algorithms
  It is recommended to replace them by calls to the optimized
       BLAS/LAPACK library for your machine
 
   (C) Adrian Sandu, Aug. 2004
 
--------------------------------------------------------------*/

#define ZERO (float)0.0
#define ONE (float)1.0
#define HALF (float)0.5
#define TWO (float)2.0
#define MOD(A, B) (int)((A) % (B))

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void WCOPY(int N, float X[], int incX, float Y[], int incY)
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    copies a vector, x, to a vector, y:  y <- x
    only for incX=incY=1
    after BLAS
    replace this by the function from the optimized BLAS implementation:
        CALL  SCOPY(N,X,1,Y,1)   or   CALL  DCOPY(N,X,1,Y,1)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
{
  int i, M;
  register __m128 x0;

  if (N <= 0)
    return;

  M = MOD(N, 4);
  if (M != 0)
  {
    for (i = 0; i < M; i++)
      Y[i] = X[i];
    if (N < 4)
      return;
  } /* end if */
  for (i = M; i < N; i += 4)
  {
    x0 = _mm_loadu_ps((float *)&X[i]);
    _mm_storeu_ps((float *)&Y[i], x0);
  } /* end for */

} /* end function WCOPY */

// /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// void WAXPY(int N, float Alpha,
//            float X[], int incX,
//            float Y[], int incY)
// /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//     constant times a vector plus a vector: y <- y + Alpha*x
//     only for incX=incY=1
//     after BLAS
//     replace this by the function from the optimized BLAS implementation:
//         CALL SAXPY(N,Alpha,X,1,Y,1) or  CALL DAXPY(N,Alpha,X,1,Y,1)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// {
//   int i, M;

//   if (Alpha == ZERO)
//     return;
//   if (N <= 0)
//     return;

//   M = MOD(N, 4);
//   if (M != 0)
//   {
//     for (i = 0; i < M; i++)
//       Y[i] = Y[i] + Alpha * X[i];
//     if (N < 4)
//       return;
//   } /* end if */

//   for (i = M; i < N; i += 4)
//   {
//     Y[i] = Y[i] + Alpha * X[i];
//     Y[i + 1] = Y[i + 1] + Alpha * X[i + 1];
//     Y[i + 2] = Y[i + 2] + Alpha * X[i + 2];
//     Y[i + 3] = Y[i + 3] + Alpha * X[i + 3];
//   } /* end for */

// } /* end function  WAXPY */

void WAXPY(int L, float a, float *x, int incX, float *y, int incY)
{

  int i, M;
  float av[] = {a, a, a, a};
  register __m128 va = _mm_load_ps(av);
  register __m128 x0, y0;

  if (a == 0)
    return;
  if (L <= 0)
    return;

  M = L % 4;
  if (M != 0)
  {
    for (i = 0; i < M; i++)
      y[i] = y[i] + a * x[i];
    if (L < 4)
      return;
  } /* end if */

  for (int i = M; i < L; i += 4)
  {
    y0 = _mm_loadu_ps((float *)&y[i]);
    x0 = _mm_loadu_ps((float *)&x[i]);
    x0 = _mm_mul_ps(va, x0);
    y0 = _mm_add_ps(y0, x0);
    _mm_storeu_ps((float *)&y[i], y0);
  }
  return;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void WSCAL(int N, float Alpha, float X[], int incX)
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    constant times a vector: x(1:N) <- Alpha*x(1:N) 
    only for incX=incY=1
    after BLAS
    replace this by the function from the optimized BLAS implementation:
        CALL SSCAL(N,Alpha,X,1) or  CALL DSCAL(N,Alpha,X,1)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
{
  int i, M;
  float av[] = {Alpha, Alpha, Alpha, Alpha};
  register __m128 va = _mm_load_ps(av);
  register __m128 x0;

  if (Alpha == ONE)
    return;
  if (N <= 0)
    return;

  M = MOD(N, 4);
  if (M != 0)
  {
    if (Alpha == (-ONE))
      for (i = 0; i < M; i++)
        X[i] = -X[i];
    else
    {
      if (Alpha == ZERO)
        for (i = 0; i < M; i++)
          X[i] = ZERO;
      else
        for (i = 0; i < M; i++)
          X[i] = Alpha * X[i];
    } /* end else */
    if (N < 4)
      return;
  } /* end if */

  if (Alpha == (-ONE))
    for (i = M; i < N; i += 4)
    {
      x0 = _mm_loadu_ps((float *)&X[i]);
      x0 = _mm_sub_ps(_mm_set1_ps(0.0), x0);
      _mm_storeu_ps((float *)&X[i], x0);

    } /* end for */
  else
  {
    if (Alpha == ZERO)
      for (i = M; i < N; i += 4)
      {
        x0 = _mm_loadu_ps((float *)&X[i]);
        x0 = _mm_setzero_ps();
        _mm_storeu_ps((float *)&X[i], x0);
      } /* end for */
    else
      for (i = M; i < N; i += 4)
      {
        x0 = _mm_loadu_ps((float *)&X[i]);
        x0 = _mm_mul_ps(va, x0);
        _mm_storeu_ps((float *)&X[i], x0);
      } /* end for */
  }     /* else  */

} /* end function WSCAL */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
float WLAMCH_ADD(float A, float B)
{
  return (A + B);
} /* end function  WLAMCH_ADD */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
float WLAMCH(char C)
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    returns epsilon machine
    after LAPACK
    replace this by the function from the optimized LAPACK implementation:
         CALL SLAMCH('E') or CALL DLAMCH('E')
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
{
  int i;
  float Suma;
  static float Eps;
  static char First = 1;

  if (First)
  {
    First = 0;
    Eps = pow(HALF, 16);
    for (i = 17; i <= 80; i++)
    {
      Eps = Eps * HALF;
      Suma = WLAMCH_ADD(ONE, Eps);
      if (Suma <= ONE)
        break;
    } /* end for */
    if (i == 80)
    {
      printf("\nERROR IN WLAMCH. Very small EPS = %g\n", Eps);
      return (double)2.2e-16;
    }
    Eps *= TWO;
    i--;
  } /* end if First */

  return Eps;

} /* end function WLAMCH */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	copies zeros into the vector y:  y <- 0 after BLAS
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void Set2Zero(int N, float Y[])
{
  int i, M;
  register __m128 y0;

  if (N <= 0)
    return;

  M = MOD(N, 4);
  if (M != 0)
  {
    for (i = 0; i < M; i++)
    {
      Y[i] = ZERO;
    }
    if (N < 4)
      return;
  } /* end if */
  for (i = M; i < N; i += 4)
  {
    y0 = _mm_setzero_ps();
    _mm_storeu_ps((float *)&Y[i], y0);
  } /* end for */
} /* end function Set2Zero */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	adds two vectors: z <- x + y     BLAS - like
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void WADD(int N, float X[], float Y[], float Z[])
{
  int i, M;
  register __m128 x0, y0;

  if (N <= 0)
    return;

  M = MOD(N, 4);
  if (M != 0)
  {
    for (i = 0; i < M; i++)
    {
      Z[i] = X[i] + Y[i];
    }
    if (N < 4)
      return;
  } /* end if */
  for (i = M; i < N; i += 4)
  {
    x0 = _mm_loadu_ps((float *)&X[i]);
    y0 = _mm_loadu_ps((float *)&Y[i]);
    x0 = _mm_add_ps(x0,y0);
    _mm_storeu_ps((float *)&Z[i], x0);
  } /* end for */
} /* end function WADD */
/* End of BLAS_UTIL function                                        */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *//* End of BLAS_UTIL function                                        */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


